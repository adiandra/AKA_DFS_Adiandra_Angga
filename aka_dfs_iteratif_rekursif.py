# -*- coding: utf-8 -*-
"""AKA_DFS_iteratif_rekursif

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1O7lsgd13tbLRNFzF6qhYKMTGNXEqp3ec
"""

import time
import matplotlib.pyplot as plt
import sys
import heapq
import networkx as nx
import itertools

# DFS Versi Iteratif (Diadaptasi untuk graf berbobot)
def dfs_iterative_all_nodes(graph, start):
    visited = set()
    stack = [(start, [start])]  # (node, path)
    all_paths = []

    while stack:
        node, path = stack.pop()

        if node not in visited:
            visited.add(node)
            all_paths.append(path)

        for neighbor, _ in graph[node]:  # Abaikan bobot (weight)
            if neighbor not in visited or neighbor not in path: #tambahan
                stack.append((neighbor, path + [neighbor]))



    return all_paths

# DFS Versi Rekursif (Diadaptasi untuk graf berbobot)
def dfs_recursive(graph, node, end, visited, path, cost, optimal_path): # Added end node as parameter
    visited.add(node)
    path.append(node)

    if node == end:  # Check if destination is reached
        if cost < optimal_path[1]:
            optimal_path[0] = path[:]  # Update optimal path
            optimal_path[1] = cost
    else:
        for neighbor, weight in graph[node]:
            if neighbor not in visited:
                dfs_recursive(graph, neighbor, end, visited, path, cost + weight, optimal_path)

    path.pop()  # Backtrack
    return optimal_path[0] # Return the optimal path


# Fungsi untuk mengukur waktu eksekusi
def measure_time(function, *args):
    start_time = time.time()
    result = function(*args)
    end_time = time.time()
    return end_time - start_time, result

# Fungsi untuk menghitung total jarak rute
def calculate_total_distance(graph, path):
    total_distance = 0
    for i in range(len(path) - 1):
        distance = None
        for neighbor, weight in graph[path[i]]:
            if neighbor == path[i + 1]:
                distance = weight
                break
        if distance is None:
            # Jika tidak ada edge langsung, asumsikan jarak tak hingga
            return float('inf')
        total_distance += distance
    return total_distance

# Fungsi untuk mencari rute terpendek yang mengunjungi semua node (Brute-Force)
def find_shortest_path_visiting_all_nodes(graph, start_node):
    nodes = list(graph.keys())
    shortest_path = None
    min_distance = float('inf')

    start_time = time.time()
    for path in itertools.permutations(nodes):
        if path[0] == start_node:
            distance = calculate_total_distance(graph, path)
            if distance < min_distance:
                min_distance = distance
                shortest_path = path
    end_time = time.time()
    compile_time = end_time - start_time

    return shortest_path, min_distance, compile_time
# Graf Jarak Tempat Wisata di Bandung (Contoh)
graph = {
    'Gedung Sate': [('Trans Studio Bandung', 5), ('Cihampelas Walk', 3)],
    'Trans Studio Bandung': [('Gedung Sate', 5), ('Farmhouse Lembang', 10), ('Floating Market', 12)],
    'Cihampelas Walk': [('Gedung Sate', 3), ('Dusun Bambu', 8)],
    'Farmhouse Lembang': [('Trans Studio Bandung', 10), ('Floating Market', 5)],
    'Floating Market': [('Farmhouse Lembang', 5), ('Trans Studio Bandung', 12), ('Dusun Bambu', 7)],
    'Dusun Bambu': [('Cihampelas Walk', 8), ('Floating Market', 7)]
}

# Tentukan titik awal dan tujuan
start_place = 'Gedung Sate'
end_place = 'Dusun Bambu'

# Pengukuran Waktu untuk DFS Iteratif dan DFS Rekursif
iterative_time, _ = measure_time(dfs_iterative, graph, start_place, end_place)
visited_recursive = set()
recursive_path = []
optimal_path_recursive = [[], float('inf')]
recursive_time, _ = measure_time(dfs_recursive, graph, start_place, end_place, visited_recursive, recursive_path, 0, optimal_path_recursive)


# Menampilkan Hasil DFS Iteratif dan Rekursif
print(f"Rute optimal dari {start_place} ke {end_place}:")
print(f"  DFS Iteratif: {iterative_path}, Waktu: {iterative_time:.6f} detik")
print(f"  DFS Rekursif: {recursive_path_result}, Waktu: {recursive_time:.6f} detik")

# Pengukuran Waktu dan Pencarian Rute untuk Brute-Force (Mengunjungi Semua Node)
shortest_path, min_distance, compile_time = find_shortest_path_visiting_all_nodes(graph, start_place)



# Data untuk Grafik Perbandingan Running Time
algorithms = ['DFS Iteratif', 'DFS Rekursif']
times = [iterative_time, recursive_time]

# Membuat Grafik Batang
plt.figure(figsize=(8, 6))
plt.bar(algorithms, times, color=['blue', 'green'])
plt.title('Perbandingan Running Time Algoritma')
plt.xlabel('Algoritma')
plt.ylabel('Waktu (detik)')
plt.show()